# 工作流名称，可自定义
name: magic

# 触发条件：定时触发 + 手动触发（方便测试）
on:
  # 定时任务：UTC 17点 = 北京时间凌晨1点
  schedule:
    - cron: '0 17 * * *'
  # 手动触发（在Actions页面可测试）
  workflow_dispatch:

# 任务执行配置
jobs:
  sync-two-repos-and-process:
    runs-on: ubuntu-latest
    steps:
      # 步骤1：检出当前仓库（用于后续提交文件）
      - name: 检出当前仓库
        uses: actions/checkout@v4

      # ==================== 处理第一个仓库（原有逻辑：提取最后一个代码块→1.txt） ====================
      - name: 处理仓库1：提取最后一个代码块生成1.txt
        run: |
          # 配置仓库1信息（替换为你的目标仓库地址）
          REPO1_URL= "https://github.com/free-nodes/v2rayfree" # "<仓库1的GitHub地址>"
          REPO1_TEMP_DIR="temp-repo1"
          REPO1_OUTPUT="1.txt"

          # 1. 克隆仓库1（仅最新版本，提速）
          git clone --depth 1 $REPO1_URL $REPO1_TEMP_DIR

          # 2. 用awk解析README.md，提取最后一个代码块
          README1_PATH="$REPO1_TEMP_DIR/README.md"
          if [ -f "$README1_PATH" ]; then
            awk '
              /^```/ {
                if (in_code) {
                  code_blocks[block_count++] = current_code
                  current_code = ""
                  in_code = 0
                } else {
                  in_code = 1
                  next
                }
              }
              in_code {
                current_code = current_code $0 "\n"
              }
              END {
                if (in_code && current_code != "") {
                  code_blocks[block_count++] = current_code
                }
                if (block_count > 0) {
                  printf "%s", code_blocks[block_count - 1] > "'"$REPO1_OUTPUT"'"
                } else {
                  echo "仓库1的README.md中未找到任何代码块" > "'"$REPO1_OUTPUT"'"
                }
              }
            ' "$README1_PATH"
          else
            echo "仓库1中未找到README.md文件" > "$REPO1_OUTPUT"
          fi

          # 3. 清理仓库1临时目录
          rm -rf $REPO1_TEMP_DIR

      # ==================== 处理第二个仓库（自定义逻辑：可修改→2.txt） ====================
      - name: 处理仓库2：自定义逻辑生成2.txt
        run: |
          # 配置仓库2信息（替换为你的目标仓库地址）
          REPO1_URL= "https://github.com/free-nodes/v2rayfree" # "<仓库1的GitHub地址>"
          REPO1_TEMP_DIR="temp-repo1"
          REPO1_OUTPUT="1.txt"

          # 1. 克隆仓库1（仅最新版本，提速）
          git clone --depth 1 $REPO1_URL $REPO1_TEMP_DIR

          # 2. 用awk解析README.md，提取最后一个代码块
          README1_PATH="$REPO1_TEMP_DIR/README.md"
          if [ -f "$README1_PATH" ]; then
            awk '
              /^```/ {
                if (in_code) {
                  code_blocks[block_count++] = current_code
                  current_code = ""
                  in_code = 0
                } else {
                  in_code = 1
                  next
                }
              }
              in_code {
                current_code = current_code $0 "\n"
              }
              END {
                if (in_code && current_code != "") {
                  code_blocks[block_count++] = current_code
                }
                if (block_count > 0) {
                  printf "%s", code_blocks[block_count - 1] > "'"$REPO1_OUTPUT"'"
                } else {
                  echo "仓库1的README.md中未找到任何代码块" > "'"$REPO1_OUTPUT"'"
                }
              }
            ' "$README1_PATH"
          else
            echo "仓库1中未找到README.md文件" > "$REPO1_OUTPUT"
          fi

          # 3. 清理仓库1临时目录
          rm -rf $REPO1_TEMP_DIR

      # 步骤4：提交并推送两个文件的更改（如有更新）
      - name: 提交并推送所有更改
        run: |
          # 配置Git用户信息
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"

          # 检查1.txt和2.txt是否有更改
          CHANGED_FILES=$(git status --porcelain | grep -E "(1.txt|2.txt)" | wc -l)
          if [ $CHANGED_FILES -gt 0 ]; then
            # 添加所有更改的文件
            git add 1.txt 2.txt
            # 提交更改
            git commit -m "Auto sync: 同步两个仓库处理结果 $(date +'%Y-%m-%d %H:%M:%S')"
            # 推送到仓库
            git push
          else
            echo "1.txt 和 2.txt 均无更新，无需提交"
          fi
